inline max x y = if x >= y then x else y

data List a where
  Nil :: List a
  Cons :: x: a -> xs: List a -> List a

termination measure len :: List a -> {Int | _v >= 0} where
  Nil -> 0
  Cons x xs -> 1 + len xs

data Tree a where
  Empty :: Tree a
  Node :: x: a -> l: Tree a -> r: Tree a -> Tree a

termination measure size :: Tree a -> {Int | _v >= 0} where
  Empty -> 0
  Node x l r -> size l + size r + 1

measure height :: Tree a -> {Int | _v >= 0} where
  Empty -> 0
  Node x l r -> 1 + max (height l) (height r)

measure telems :: Tree a -> Set a where
  Empty -> []
  Node x l r -> telems l + telems r + [x]


type Nat = {Int | _v >= 0}

-- Used in Myth
append :: xs: List a -> ys: List a -> {List a | len _v == len xs + len ys}

-- Escher Extra Components
isLeaf :: t: Tree a -> {Bool | _v == (size t == 1)}


data NatTree where
  NTLeaf :: NatTree
  NTNode :: NatTree -> Nat -> NatTree -> NatTree

termination measure sizeTree :: NatTree -> {Int | _v >= 0} where
  NTLeaf -> 0
  NTNode left x right -> 1 + sizeTree left + sizeTree right

-- checks
count_nodes_at_lvl :: t:NatTree -> l:Nat -> { Nat |
   ((t == NTLeaf ) ==> _v == 0) &&
   ((t == (NTNode NTLeaf 0 NTLeaf) && l==0) ==> _v == (1)) &&
   ((t == (NTNode (NTNode NTLeaf 0 NTLeaf) 0 NTLeaf) && l==1) ==> _v == (1)) &&
   ((t == (NTNode NTLeaf 0 (NTNode NTLeaf 0 NTLeaf)) && l==1) ==> _v == (1)) &&
   ((t == (NTNode (NTNode NTLeaf 0 (NTNode NTLeaf 0 NTLeaf)) 0 NTLeaf) && l==2) ==> _v == (1)) &&
   ((t == (NTNode NTLeaf 0 (NTNode NTLeaf 0 (NTNode NTLeaf 0 NTLeaf))) && l==2) ==> _v == (1)) &&
   True
}
count_nodes_at_lvl = \t. \level.
    match t with
      NTLeaf -> 0
      NTNode left x right ->
        if level == 0
        then 1
        else (count_nodes_at_lvl left (level - 1)) + (count_nodes_at_lvl right (level - 1))


-- Error:
-- Cannot find sufficiently strong refinements
--  when checking (append .. ..)
-- nodes_at_level :: (tree:Tree Int -> l:Nat -> {List Int |
--     (tree == Empty ==> _v == Nil) &&
--     ((tree == Node 1 Empty Empty && l == 0) ==> _v == Cons 1 Nil) &&
--     ((tree == Node 1 Empty Empty && l == 1) ==> _v == Nil) &&
--     ((tree == Node 2 Empty Empty && l == 0) ==> _v == (Cons 2 Nil)) &&
--     ((tree == Node 3 Empty Empty && l == 0) ==> _v == (Cons 3 Nil)) &&
--     ((tree == Node 1 (Node 2 Empty Empty) (Node 3 Empty Empty) && l == 1) ==> _v == (Cons 2 (Cons 3 Nil))) &&
--     True}) ^
--     (Tree a -> Nat -> List a) -- This attempts to make it polymorphic,
--                               -- could not find any interesting properties
-- nodes_at_level = \t. \level.
--   match t with
--     Empty -> Nil
--     Node x left right ->
--       if level == 0
--       then Cons x Nil
--       else append (nodes_at_level left (level - 1)) (nodes_at_level right (level - 1))