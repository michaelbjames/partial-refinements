-- data List a where
-- 	Nil :: List a
-- 	Cons :: x: a -> xs: List a -> List a

-- termination measure len :: List a -> {Int | _v >= 0} where
--   Nil -> 0
--   Cons x xs -> 1 + len xs

-- foldl :: (f: (b -> a -> b) -> b -> List a -> b) ^
--   (f: (acc:b -> a -> {b|_v == acc}) -> seed: b -> List a -> {b | _v == seed}) ^
--   (f: (acc:Int -> a -> {Int | _v == acc + 1}) -> seed: {Int | _v == 0} -> xs: List a -> {Int | _v == len xs})
-- foldl = \f. \seed. \xs.
--   match xs with
--     Nil -> seed
--     Cons y ys -> foldl f (f seed y) ys

{-
top spec:
match xs with
  Nil -> seed
  Cons y ys -> seed

bottom spec:
match xs with
  Nil -> 0/seed
  Cons y ys -> 1 + foldl f seed ys
  Cons y ys -> f (foldl f seed ys) y -- this is foldr!, though foldl is equally likely
-}


data OList a <p :: Int -> a -> Bool> where
  ONil :: OList a <p>
  OCons :: x: {a | p 0 _v} -> xs: OList a <{p (_0 + 1) _1}> -> OList a <p>

termination measure len :: OList a -> {Int | _v >= 0} where
  ONil -> 0
  OCons x xs -> 1 + len xs

-- use minus for a concrete non-communicative operation
-- myth requires tables for HOF defs
foldl :: <p :: Int -> a -> Bool> . (f: (b -> a -> b) -> b -> OList a <p> -> b) ^
  (f: (acc:b -> a -> {b|_v == acc}) -> seed: b -> List a -> {b | _v == seed}) ^
  (f: (acc:Int -> x:a -> {Int | _v == acc && p acc x}) -> seed: {Int | _v == 0} -> xs: List a -> {Int | _v == len xs})
foldl = \f. \seed. \xs.
  match xs with
    ONil -> seed
    OCons y ys -> foldl f (f seed y) ys

type List a = OList a <{True}>

-- foldl2 :: ((b -> a -> b) -> b -> List a -> b) ^
--           (f: (a:Int -> b:Int -> {Int | _v == a - b}) ->
--             {Int | _v == 0} ->
--             {List Int | _v == (OCons 1 (OCons 2 ONil)} ->
--               {Int | _v == (-3)})
-- foldl2 = \f. \seed. \xs.
--   match xs with
--     ONil -> seed
--     OCons y ys -> foldl2 f (f seed y) ys
