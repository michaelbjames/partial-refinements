data List a where
  Nil :: List a
  Cons :: x: a -> xs: List a -> List a

termination measure len :: List a -> {Int | _v >= 0} where
  Nil -> 0
  Cons x xs -> 1 + len xs

-- Not strong enough...
pairs :: ((a -> a -> a) -> xs:{List a | len _v > 1} -> {List a | (2 * len _v >= len xs) && (len _v < len xs)}) ^
         ((a -> a -> a) -> xs:{List a | len _v <= 1} -> {List a | _v == xs})
-- This is strong enough.
-- pairs :: (a -> a -> a) -> xs:List a -> {List a |
--       ((len xs > 1) ==> ((2 * len _v >= len xs) && len _v < len xs)) &&
--       ((len xs <= 1) ==> (_v == xs)) &&
--       True}
pairs = \f. \xs.
  match xs with
    Nil -> Nil
    Cons y ys ->
      match ys with
        Nil -> Cons y ys
        Cons z zs -> Cons (f y z) (pairs f zs)


{-
from: https://wiki.haskell.org/Fold
foldt            :: (a -> a -> a) -> a -> [a] -> a
foldt f z []     = z
foldt f z [x]    = x                             -- aka foldt' of data-ordlist
foldt f z xs     = foldt f z (pairs f xs)

foldi            :: (a -> a -> a) -> a -> [a] -> a
foldi f z []     = z
foldi f z (x:xs) = f x (foldi f z (pairs f xs))  -- aka foldt of data-ordlist

pairs            :: (a -> a -> a) -> [a] -> [a]
pairs f (x:y:t)  = f x y : pairs f t
pairs f t        = t
-}

-- foldl :: <p Int -> a -> Bool> . (f: (b -> a -> b) -> b -> List <p> a -> b) ^
--   (f: (acc:b -> a -> {b|_v == acc}) -> seed: b -> List <p> a -> {b | _v == seed}) ^
--   (f: (acc:Int -> x:a -> {Int | _v == p acc x}) -> seed: {Int | _v == 0} -> xs: List a -> {Int | _v == len xs}) ^
--   (f: (acc:{b|True} -> x:{a|True} -> {b|True}))
-- foldl = \f. \seed. \xs.
--   match xs with
--     Nil -> seed
--     Cons y ys -> foldl f (f seed y) ys