-- data List a where
-- 	Nil :: List a
-- 	Cons :: x: a -> xs: List a -> List a

-- termination measure len :: List a -> {Int | _v >= 0} where
--   Nil -> 0
--   Cons x xs -> 1 + len xs

-- foldl :: (f: (b -> a -> b) -> b -> List a -> b) ^
--   (f: (acc:b -> a -> {b|_v == acc}) -> seed: b -> List a -> {b | _v == seed}) ^
--   (f: (acc:Int -> a -> {Int | _v == acc + 1}) -> seed: {Int | _v == 0} -> xs: List a -> {Int | _v == len xs})
-- foldl = \f. \seed. \xs.
--   match xs with
--     Nil -> seed
--     Cons y ys -> foldl f (f seed y) ys

{-
top spec:
match xs with
  Nil -> seed
  Cons y ys -> seed

bottom spec:
match xs with
  Nil -> 0/seed
  Cons y ys -> 1 + foldl f seed ys
  Cons y ys -> f (foldl f seed ys) y -- this is foldr!, though foldl is equally likely
-}


data OList a <p :: Int -> a -> Bool> where
  ONil :: OList a <p>
  OCons :: x: {a | p 0 _v} -> xs: OList a <{p (_0 + 1) _1}> -> OList a <p>

termination measure olen :: OList a -> {Int | _v >= 0} where
  ONil -> 0
  OCons x xs -> 1 + len xs


foldl :: <p Int -> a -> Bool> . (f: (b -> a -> b) -> b -> OList <p> a -> b) ^
  (f: (acc:b -> a -> {b|_v == acc}) -> seed: b -> List <p> a -> {b | _v == seed}) ^
  (f: (acc:Int -> x:a -> {Int | _v == p acc x}) -> seed: {Int | _v == 0} -> xs: List a -> {Int | _v == len xs}) ^
  (f: (acc:{b|True} -> x:{a|True} -> {b|True}))
foldl = \f. \seed. \xs.
  match xs with
    Nil -> seed
    Cons y ys -> foldl f (f seed y) ys