data OList a <p :: Int -> a -> Bool> where
  Nil :: OList a <p>
  Cons :: x: {a | p 0 _v} -> xs: OList a <{p (_0 + 1) _1}> -> OList a <p>

termination measure len :: OList a -> {Int | _v >= 0} where
  Nil -> 0
  Cons x xs -> 1 + len xs

type List a = OList a <{True}>

{-
The OList maintains an ordering on the list in the predicate.
So, a fold over such a list counting elements seen will produce a number
that is exactly the length of the list. The count will also map to each
element's ordinal position in the OList.
The core idea of this fold doesn't specify a direction. However,
the left-fold would not prove under this spec. The left direction
is not inductive!
-}
foldr :: <p :: Int -> a -> Bool> .
  (xs: OList a <p> -> f: (a -> b -> b) -> b -> b) ^
  (xs: OList a <p> -> f: (x:a -> acc:Int -> {Int | _v == acc + 1 && p acc x}) -> seed: {Int|_v == 0} -> {Int | _v == len xs})
foldr = \xs. \f. \seed.
  match xs with
    Nil -> seed
    -- Cons y ys -> foldr ys f (f y seed) -- foldl
    Cons y ys -> ?? -- f y (foldr ys f seed) -- foldr