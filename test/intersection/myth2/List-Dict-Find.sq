data Pair a b where
	Pair :: x: a -> y: b -> Pair a b

measure fst :: Pair a b -> a where
  Pair x y -> x

measure snd :: Pair a b -> b where
  Pair x y -> y


data List a where
	Nil :: List a
	Cons :: x: a -> xs: List a -> List a

termination measure len :: List a -> {Int | _v >= 0} where
  Nil -> 0
  Cons x xs -> 1 + len xs

measure insert :: x: a -> List a -> {List a|True} where
  Nil -> Cons x Nil
  Cons y ys -> Cons x (Cons y ys)


-- Not strong enough??
-- find :: List (Pair a b) -> a -> Bool
find :: (a -> Int -> List (Pair a Int) -> Int) ^
      (a -> def: Int -> {List (Pair a Int) | len _v == 0} -> {Int | _v == def})
-- find :: x: Int -> def: Int -> xs: List (Pair Int Int) -> {Int |
--     ((x == 0 && xs == (Nil)) ==> (_v == def)) &&
--     ((x == 0 && xs == (Cons (Pair 0 4) Nil)) ==> (_v == 4)) &&
--     ((x == 0 && xs == (Cons (Pair 1 5) (Cons (Pair 0 4) Nil))) ==> (_v == 4)) &&
--     True
--   }
find = \needle. \def. \haystack.
  match haystack with
    Nil -> def
    Cons x xs ->
      match x with
        Pair xa xb -> if xa == needle
          then xb
          else find needle def xs