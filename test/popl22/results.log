---------------------------------------------------------------
All-Neg:
---------------------------------------------------------------
guarded powerset:
allNeg :: (xs:{List {Int|_v < 0}|len _v == 0} -> {Bool|_v == True}) ^ ((xs:{List {Int|_v < 0}|len _v > 0} -> {Bool|_v == True}) ^ (xs:{List Nat|len _v > 0} -> {Bool|_v == False}))
allNeg = \xs . 
  match xs with
    Nil -> True
    Cons y ys -> 
      if y >= 0
        then False
        else allNeg ys

(Goals: 2)
(Measures: 1)
(Spec size: 30)
(Solution size: 25)

either/or:
allNeg :: (xs:{List {Int|_v < 0}|len _v == 0} -> {Bool|_v == True}) ^ ((xs:{List {Int|_v < 0}|len _v > 0} -> {Bool|_v == True}) ^ (xs:{List Nat|len _v > 0} -> {Bool|_v == False}))
allNeg = \xs . 
  match xs with
    Nil -> True
    Cons y ys -> 
      if y >= 0
        then False
        else allNeg ys

(Goals: 2)
(Measures: 1)
(Spec size: 30)
(Solution size: 25)

laurent-BCD:
allNeg :: (xs:{List {Int|_v < 0}|len _v == 0} -> {Bool|_v == True}) ^ ((xs:{List {Int|_v < 0}|len _v > 0} -> {Bool|_v == True}) ^ (xs:{List Nat|len _v > 0} -> {Bool|_v == False}))
allNeg = \xs . 
  match xs with
    Nil -> True
    Cons y ys -> 
      if y >= 0
        then False
        else allNeg ys

(Goals: 2)
(Measures: 1)
(Spec size: 30)
(Solution size: 25)
---------------------------------------------------------------
List-Dict-Contains:
---------------------------------------------------------------
guarded powerset:
contains :: (x:Int -> arg0:List Pair Int b -> Bool) ^ (x:a -> arg0:{List Pair a b|len _v == 0} -> {Bool|_v == False})
List-Dict-Contains.sq:42: Error:
  Cannot find sufficiently strong refinements
  when checking contains
                  needle :: X5:_ -> Bool in
  \needle . \haystack . 
      match haystack with
        Cons x xs -> 
          match x with
            Pair xa xb -> 
              if xa == needle
                then True
                else contains needle (?? :: [_])


either/or:
contains :: (x:Int -> arg0:List Pair Int b -> Bool) ^ (x:a -> arg0:{List Pair a b|len _v == 0} -> {Bool|_v == False})
contains = \needle . \haystack .
    
    match haystack with
      Nil -> False
      Cons x xs -> 
        match x with
          Pair xa xb -> 
            if xa == needle
              then True
              else contains needle xs

(Goals: 5)
(Measures: 4)
(Spec size: 10)
(Solution size: 56)

laurent-BCD: timeout
---------------------------------------------------------------
List-Dict-Find:
---------------------------------------------------------------
guarded powerset:
find :: (arg2:List Pair Int b -> arg1:Int -> arg0:b -> b) ^ (arg2:{List Pair Int Int|len _v == 0} -> arg1:Int -> default:Int -> {Int|_v == default})
find = \haystack . \needle .
    \def . 
      match haystack with
        Nil -> def
        Cons x xs -> 
          match x with
            Pair xa xb -> 
              if xa == needle
                then xb
                else find xs needle def

(Goals: 5)
(Measures: 4)
(Spec size: 10)
(Solution size: 59)

either/or:
find :: (arg2:List Pair Int b -> arg1:Int -> arg0:b -> b) ^ (arg2:{List Pair Int Int|len _v == 0} -> arg1:Int -> default:Int -> {Int|_v == default})
find = \haystack . \needle .
    \def . 
      match haystack with
        Nil -> def
        Cons x xs -> 
          match x with
            Pair xa xb -> 
              if xa == needle
                then xb
                else find xs needle def

(Goals: 5)
(Measures: 4)
(Spec size: 10)
(Solution size: 59)

laurent-BCD:
find :: (arg2:List Pair Int b -> arg1:Int -> arg0:b -> b) ^ (arg2:{List Pair Int Int|len _v == 0} -> arg1:Int -> default:Int -> {Int|_v == default})
find = \haystack . \needle .
    \def . 
      match haystack with
        Nil -> def
        Cons x xs -> 
          match x with
            Pair xa xb -> 
              if xa == needle
                then xb
                else find xs needle def

(Goals: 5)
(Measures: 4)
(Spec size: 10)
(Solution size: 59)
---------------------------------------------------------------
List-Even-Parity:
---------------------------------------------------------------
guarded powerset:
list_even_parity :: (xs:List Bool -> Bool) ^ ((xs:{List {Bool|_v == True}|len _v == 2 || len _v == 0} -> {Bool|_v == True}) ^ (xs:{List {Bool|_v == True}|len _v == 3 || len _v == 1} -> {Bool|_v == False}))
list_even_parity = \xs . 
  match xs with
    Nil -> True
    Cons y ys -> 
      if y
        then not (list_even_parity ys)
        else list_even_parity ys

(Goals: 2)
(Measures: 1)
(Spec size: 33)
(Solution size: 25)

either/or:
list_even_parity :: (xs:List Bool -> Bool) ^ ((xs:{List {Bool|_v == True}|len _v == 2 || len _v == 0} -> {Bool|_v == True}) ^ (xs:{List {Bool|_v == True}|len _v == 3 || len _v == 1} -> {Bool|_v == False}))
list_even_parity = \xs . 
  match xs with
    Nil -> True
    Cons y ys -> 
      if y
        then not (list_even_parity ys)
        else list_even_parity ys

(Goals: 2)
(Measures: 1)
(Spec size: 33)
(Solution size: 25)

laurent-BCD: timeout
---------------------------------------------------------------
List-Fold:
---------------------------------------------------------------
guarded powerset:
foldl :: (xs:List a -> f:(acc:b -> x:a -> b) -> seed:b -> b) ^ (xs:List Int -> f:(acc:Int -> x:Int -> {Int|_v == acc + 1}) -> seed:Int -> {Int|_v == len xs + seed})
List-Fold.sq:16: Error:
  Cannot find sufficiently strong refinements
  when checking foldl
                  ys :: X2:_ -> X1:_ -> b in
  \xs . \f . \seed . 
        match xs with
          Cons y ys -> foldl ys
                         (?? :: [_]) (?? :: [_])


either/or:
foldl :: (xs:List a -> f:(acc:b -> x:a -> b) -> seed:b -> b) ^ (xs:List Int -> f:(acc:Int -> x:Int -> {Int|_v == acc + 1}) -> seed:Int -> {Int|_v == len xs + seed})
List-Fold.sq:16: Error:
  Cannot match shape, unresolvable subtype:
  'Int' : {Int|_v == len ys + X1} </: 'b' : b from label 'checkE-subtype'
  when checking foldl
                  ys :: X2:_ -> X1:_ -> b in
  \xs . \f . \seed . 
        match xs with
          Cons y ys -> foldl ys
                         (?? :: [_]) (?? :: [_])


laurent-BCD: timeout
---------------------------------------------------------------
List-Inc:
---------------------------------------------------------------
guarded powerset:
map :: f:(arg0:a -> b) -> xs:List a -> {List b|len _v == len xs}
map = \f . \xs . 
    match xs with
      Nil -> Nil
      Cons x3 x4 -> 
        let f0 = (?? :: [_]) in
        Cons (f x3) (map (\X10 . X10)
                       x4)

list_inc_intersect :: (xs:List Int -> List Int) ^ ((xs:List {Int|_v == 1} -> List {Int|_v == 2}) ^ (xs:{List Int|len _v == 1} -> {List Int|len _v == 1}))
list_inc_intersect = \x . 
  let f = (?? :: [_]) in
  map (\X4 . X4) x

(Goals: 4)
(Measures: 2)
(Spec size: 25)
(Solution size: 48)

either/or:
map :: f:(arg0:a -> b) -> xs:List a -> {List b|len _v == len xs}
map = \f . \xs . 
    match xs with
      Nil -> Nil
      Cons x3 x4 -> 
        let f0 = (?? :: [_]) in
        Cons (f x3) (map f x4)

list_inc_intersect :: (xs:List Int -> List Int) ^ ((xs:List {Int|_v == 1} -> List {Int|_v == 2}) ^ (xs:{List Int|len _v == 1} -> {List Int|len _v == 1}))
list_inc_intersect = \x . 
  let f = (?? :: [_]) in
  map (\X4 . X4) x

(Goals: 4)
(Measures: 2)
(Spec size: 25)
(Solution size: 47)

laurent-BCD:
map :: f:(arg0:a -> b) -> xs:List a -> {List b|len _v == len xs}
map = \f . \xs . 
    match xs with
      Nil -> Nil
      Cons x3 x4 -> 
        let f0 = (?? :: [_]) in
        Cons (f x3) (map (\X10 . X10)
                       x4)

list_inc_intersect :: (xs:List Int -> List Int) ^ ((xs:List {Int|_v == 1} -> List {Int|_v == 2}) ^ (xs:{List Int|len _v == 1} -> {List Int|len _v == 1}))
list_inc_intersect = \x . 
  let f = (?? :: [_]) in
  map (\X4 . X4) x

(Goals: 4)
(Measures: 2)
(Spec size: 25)
(Solution size: 48)
---------------------------------------------------------------
List-Last:
---------------------------------------------------------------
guarded powerset:
list_last :: (xs:List Int -> Maybe Int) ^ ((xs:{List Int|len _v == 0} -> {Maybe Int|isNothing _v}) ^ (xs:{List Int|len _v > 0} -> {Maybe Int|!isNothing _v}))
list_last = \xs . 
  match xs with
    Nil -> Nothing
    Cons x rest -> 
      match rest with
        Nil -> Just x
        Cons y ys -> list_last rest

(Goals: 4)
(Measures: 3)
(Spec size: 19)
(Solution size: 39)

either/or:
list_last :: (xs:List Int -> Maybe Int) ^ ((xs:{List Int|len _v == 0} -> {Maybe Int|isNothing _v}) ^ (xs:{List Int|len _v > 0} -> {Maybe Int|!isNothing _v}))
list_last = \xs . 
  match xs with
    Nil -> Nothing
    Cons x rest -> 
      match rest with
        Nil -> Just x
        Cons y ys -> list_last rest

(Goals: 4)
(Measures: 3)
(Spec size: 19)
(Solution size: 39)

laurent-BCD:
list_last :: (xs:List Int -> Maybe Int) ^ ((xs:{List Int|len _v == 0} -> {Maybe Int|isNothing _v}) ^ (xs:{List Int|len _v > 0} -> {Maybe Int|!isNothing _v}))
list_last = \xs . 
  match xs with
    Nil -> Nothing
    Cons x rest -> 
      match rest with
        Nil -> Just x
        Cons y ys -> list_last rest

(Goals: 4)
(Measures: 3)
(Spec size: 19)
(Solution size: 39)
---------------------------------------------------------------
List-Length:
---------------------------------------------------------------
guarded powerset:
length :: (zs:{List Int|len _v == 0} -> {Int|_v == 0}) ^ (zs:{List Int|len _v > 0} -> {Int|_v == len zs})
length = \zs . 
  match zs with
    Nil -> 0
    Cons y ys -> 1 + (length ys)

(Goals: 2)
(Measures: 1)
(Spec size: 18)
(Solution size: 22)

either/or:
length :: (zs:{List Int|len _v == 0} -> {Int|_v == 0}) ^ (zs:{List Int|len _v > 0} -> {Int|_v == len zs})
length = \zs . 
  match zs with
    Nil -> 0
    Cons y ys -> 1 + (length ys)

(Goals: 2)
(Measures: 1)
(Spec size: 18)
(Solution size: 22)

laurent-BCD:
length :: (zs:{List Int|len _v == 0} -> {Int|_v == 0}) ^ (zs:{List Int|len _v > 0} -> {Int|_v == len zs})
length = \zs . 
  match zs with
    Nil -> 0
    Cons y ys -> 1 + (length ys)

(Goals: 2)
(Measures: 1)
(Spec size: 18)
(Solution size: 22)
---------------------------------------------------------------
List-Snoc:
---------------------------------------------------------------
guarded powerset:
snoc :: (xs:List a -> x:a -> {List a|len _v == len xs + 1}) ^ ((xs:{List a|_v == (Nil)} -> x:a -> {List a|_v == (Cons x (Nil))}) ^ (xs:{List Int|_v == (Cons 2 (Nil))} -> x:{Int|_v == 1} -> {List Int|_v == (Cons 2 ((Cons 1 (Nil))))}))

either/or:
snoc :: (xs:List a -> x:a -> {List a|len _v == len xs + 1}) ^ ((xs:{List a|_v == (Nil)} -> x:a -> {List a|_v == (Cons x (Nil))}) ^ (xs:{List Int|_v == (Cons 2 (Nil))} -> x:{Int|_v == 1} -> {List Int|_v == (Cons 2 ((Cons 1 (Nil))))}))

laurent-BCD:
snoc :: (xs:List a -> x:a -> {List a|len _v == len xs + 1}) ^ ((xs:{List a|_v == (Nil)} -> x:a -> {List a|_v == (Cons x (Nil))}) ^ (xs:{List Int|_v == (Cons 2 (Nil))} -> x:{Int|_v == 1} -> {List Int|_v == (Cons 2 ((Cons 1 (Nil))))}))
---------------------------------------------------------------
List-Sum:
---------------------------------------------------------------
guarded powerset:
sum :: (xs:List Int -> Int) ^ (xs:List {Int|_v == 3} -> {Int|_v == 3 * len xs})
sum = \xs . 
  match xs with
    Nil -> 0
    Cons y ys -> plus y (sum ys)

(Goals: 2)
(Measures: 1)
(Spec size: 12)
(Solution size: 22)

either/or:
sum :: (xs:List Int -> Int) ^ (xs:List {Int|_v == 3} -> {Int|_v == 3 * len xs})
sum = \xs . 
  match xs with
    Nil -> 0
    Cons y ys -> plus y (sum ys)

(Goals: 2)
(Measures: 1)
(Spec size: 12)
(Solution size: 22)

laurent-BCD: timeout
---------------------------------------------------------------
List-toFalse:
---------------------------------------------------------------
guarded powerset:
listToFalse :: (zs:{List Int|len _v == 0} -> {Bool|_v == False}) ^ (zs:{List Int|len _v > 0} -> {Bool|_v == False})
listToFalse = \zs . 
  match zs with
    Nil -> False
    Cons y ys -> listToFalse ys

(Goals: 2)
(Measures: 1)
(Spec size: 17)
(Solution size: 18)

either/or:
listToFalse :: (zs:{List Int|len _v == 0} -> {Bool|_v == False}) ^ (zs:{List Int|len _v > 0} -> {Bool|_v == False})
listToFalse = \zs . 
  match zs with
    Nil -> False
    Cons y ys -> listToFalse ys

(Goals: 2)
(Measures: 1)
(Spec size: 17)
(Solution size: 18)

laurent-BCD:
listToFalse :: (zs:{List Int|len _v == 0} -> {Bool|_v == False}) ^ (zs:{List Int|len _v > 0} -> {Bool|_v == False})
listToFalse = \zs . 
  match zs with
    Nil -> False
    Cons y ys -> listToFalse ys

(Goals: 2)
(Measures: 1)
(Spec size: 17)
(Solution size: 18)
---------------------------------------------------------------
TakeWhile:
---------------------------------------------------------------
guarded powerset:
takeWhile :: <p :: a -> Bool> . (pred:(x:a -> {Bool|_v == p x}) -> xs:List a -> List {a|p _v}) ^ (pred:(x:a -> {Bool|_v == p x}) -> xs:List {a|p _v} -> {List a|_v == xs})
takeWhile = \pred . \xs . 
    match xs with
      Nil -> Nil
      Cons y ys -> 
        if pred y
          then Cons y (takeWhile pred ys)
          else Nil

(Goals: 2)
(Measures: 1)
(Spec size: 18)
(Solution size: 30)

either/or:
takeWhile :: <p :: a -> Bool> . (pred:(x:a -> {Bool|_v == p x}) -> xs:List a -> List {a|p _v}) ^ (pred:(x:a -> {Bool|_v == p x}) -> xs:List {a|p _v} -> {List a|_v == xs})
takeWhile = \pred . \xs . 
    match xs with
      Nil -> Nil
      Cons y ys -> 
        if pred y
          then Cons y (takeWhile pred ys)
          else Nil

(Goals: 2)
(Measures: 1)
(Spec size: 18)
(Solution size: 30)

laurent-BCD:
takeWhile :: <p :: a -> Bool> . (pred:(x:a -> {Bool|_v == p x}) -> xs:List a -> List {a|p _v}) ^ (pred:(x:a -> {Bool|_v == p x}) -> xs:List {a|p _v} -> {List a|_v == xs})
takeWhile = \pred . \xs . 
    match xs with
      Nil -> Nil
      Cons y ys -> 
        if pred y
          then Cons y (takeWhile pred ys)
          else Nil

(Goals: 2)
(Measures: 1)
(Spec size: 18)
(Solution size: 30)
