---------------------------------------------------------------
All-Neg:
---------------------------------------------------------------
guarded powerset: timeout

either/or:
allNeg :: (xs:List {Int|_v < 0} -> {Bool|_v == True}) ^ ((xs:{List Nat|len _v > 0} -> {Bool|_v == False}) ^ (xs:{List Int|_v == (Cons (-1) ((Cons 1 (Nil))))} -> {Bool|_v == False}))
allNeg = \xs . 
  match xs with
    Nil -> true
    Cons x4 x5 -> 
      if x4 >= 0
        then false
        else 
          match x5 with
            Nil -> true
            Cons x6 x7 -> 
              if x6 >= 0
                then false
                else true

(Goals: 2)
(Measures: 1)
(Spec size: 27)
(Solution size: 33)

laurent-BCD: timeout
---------------------------------------------------------------
List-Dict-Contains:
---------------------------------------------------------------
guarded powerset:
contains :: (x:Int -> arg0:List Pair Int b -> Bool) ^ (x:a -> arg0:{List Pair a b|len _v == 0} -> {Bool|_v == False})
List-Dict-Contains.sq:42: Error:
  Cannot find sufficiently strong refinements
  when checking
  contains :: x6:_ -> x5:_ -> Bool
  in
  \needle . \haystack . 
      match haystack with
        Cons x xs -> 
          match x with
            Pair xa xb -> 
              if xa == needle
                then True
                else contains (?? :: [_])
                       (?? :: [_])


either/or:
contains :: (x:Int -> arg0:List Pair Int b -> Bool) ^ (x:a -> arg0:{List Pair a b|len _v == 0} -> {Bool|_v == False})
List-Dict-Contains.sq:42: Error:
  Cannot match shape, unresolvable subtype:
  'a' : {a|_v == needle} </: 'Int' : {Int|U17} from label 'checkE-subtype'
  when checking needle :: Int in
  \needle . \haystack . 
      match haystack with
        Cons x xs -> 
          match x with
            Pair xa xb -> 
              if xa == needle
                then True
                else contains needle (?? :: [_])


laurent-BCD: timeout
---------------------------------------------------------------
List-Dict-Find:
---------------------------------------------------------------
guarded powerset:
List-Dict-Find.sq:19: Resolution Error:
  Cannot unify sorts Int and a


either/or:
List-Dict-Find.sq:19: Resolution Error:
  Cannot unify sorts Int and a


laurent-BCD:
List-Dict-Find.sq:19: Resolution Error:
  Cannot unify sorts Int and a

---------------------------------------------------------------
List-Even-Parity:
---------------------------------------------------------------
guarded powerset: timeout

either/or:
list_even_parity :: (xs:List Bool -> Bool) ^ ((xs:{List {Bool|_v == True}|len _v == 2 || len _v == 0} -> {Bool|_v == True}) ^ (xs:{List {Bool|_v == True}|len _v == 3 || len _v == 1} -> {Bool|_v == False}))
list_even_parity = \xs . 
  match xs with
    Nil -> true
    Cons x4 x5 -> 
      if ! x4
        then x4
        else not (list_even_parity x5)

(Goals: 2)
(Measures: 1)
(Spec size: 33)
(Solution size: 25)

laurent-BCD: timeout
---------------------------------------------------------------
List-Fold:
---------------------------------------------------------------
guarded powerset: timeout

either/or:
foldl :: (xs:List a -> f:(acc:b -> x:a -> b) -> seed:b -> b) ^ ((xs:List a -> f:(acc:Int -> arg0:a -> {Int|_v == acc + 1}) -> seed:Int -> {Int|_v == len xs + seed}) ^ (xs:List Int -> f:(acc:Int -> x:Int -> {Int|_v == acc + 1}) -> seed:Int -> {Int|_v == len xs + seed}))

laurent-BCD: timeout
---------------------------------------------------------------
List-Inc:
---------------------------------------------------------------
guarded powerset:
map :: f:(arg0:a -> b) -> xs:List a -> {List b|len _v == len xs}
map = \f . \xs . 
    match xs with
      Nil -> Nil
      Cons x3 x4 -> 
        let f0 = f in
        Cons (f x3) (map f0 x4)

list_inc_intersect :: (xs:List Int -> List Int) ^ ((xs:List {Int|_v == 1} -> List {Int|_v == 2}) ^ (xs:{List Int|len _v == 1} -> {List Int|len _v == 1}))
list_inc_intersect = \xs . map
                             inc xs

(Goals: 4)
(Measures: 2)
(Spec size: 25)
(Solution size: 46)

either/or:
map :: f:(arg0:a -> b) -> xs:List a -> {List b|len _v == len xs}
map = \f . \xs . 
    match xs with
      Nil -> Nil
      Cons x3 x4 -> 
        let f0 = f in
        Cons (f x3) (map f0 x4)

list_inc_intersect :: (xs:List Int -> List Int) ^ ((xs:List {Int|_v == 1} -> List {Int|_v == 2}) ^ (xs:{List Int|len _v == 1} -> {List Int|len _v == 1}))
list_inc_intersect = \xs . map
                             inc xs

(Goals: 4)
(Measures: 2)
(Spec size: 25)
(Solution size: 46)

laurent-BCD: timeout
---------------------------------------------------------------
List-Last:
---------------------------------------------------------------
guarded powerset: timeout

either/or: timeout

laurent-BCD: timeout
---------------------------------------------------------------
List-Length:
---------------------------------------------------------------
guarded powerset:
length :: (zs:{List Int|len _v == 0} -> {Int|_v == 0}) ^ (zs:{List Int|len _v > 0} -> {Int|_v == len zs})
length = \zs . 
  match zs with
    Nil -> zero
    Cons x3 x4 -> inc (length x4)

(Goals: 2)
(Measures: 1)
(Spec size: 18)
(Solution size: 20)

either/or:
length :: (zs:{List Int|len _v == 0} -> {Int|_v == 0}) ^ (zs:{List Int|len _v > 0} -> {Int|_v == len zs})
length = \zs . 
  match zs with
    Nil -> zero
    Cons x3 x4 -> 
      match x4 with
        Nil -> inc zero
        Cons x6 x7 -> inc (length x4)

(Goals: 2)
(Measures: 1)
(Spec size: 18)
(Solution size: 25)

laurent-BCD: timeout
---------------------------------------------------------------
List-Snoc:
---------------------------------------------------------------
guarded powerset:
snoc :: (xs:List a -> x:a -> {List a|len _v == len xs + 1}) ^ ((xs:{List Int|_v == (Nil)} -> x:{Int|_v == 1} -> {List Int|_v == (Cons 1 (Nil))}) ^ (xs:{List Int|_v == (Cons 2 (Nil))} -> x:{Int|_v == 1} -> {List Int|_v == (Cons 2 ((Cons 1 (Nil))))}))
snoc = \xs . \x . 
    match xs with
      Nil -> Cons x xs
      Cons x6 x7 -> Cons x6 (Cons x
                               x7)

(Goals: 2)
(Measures: 1)
(Spec size: 36)
(Solution size: 29)

either/or:
snoc :: (xs:List a -> x:a -> {List a|len _v == len xs + 1}) ^ ((xs:{List Int|_v == (Nil)} -> x:{Int|_v == 1} -> {List Int|_v == (Cons 1 (Nil))}) ^ (xs:{List Int|_v == (Cons 2 (Nil))} -> x:{Int|_v == 1} -> {List Int|_v == (Cons 2 ((Cons 1 (Nil))))}))
snoc = \xs . \x . 
    match xs with
      Nil -> Cons x xs
      Cons x6 x7 -> Cons x6 (Cons x
                               x7)

(Goals: 2)
(Measures: 1)
(Spec size: 36)
(Solution size: 29)

laurent-BCD: timeout
---------------------------------------------------------------
List-Sum:
---------------------------------------------------------------
guarded powerset:
sum :: (xs:List Int -> Int) ^ (xs:List {Int|_v == 3} -> {Int|_v == 3 * len xs})
sum = \xs . 
  match xs with
    Nil -> zero
    Cons x3 x4 -> plus x3 (sum x4)

(Goals: 2)
(Measures: 1)
(Spec size: 12)
(Solution size: 22)

either/or:
sum :: (xs:List Int -> Int) ^ (xs:List {Int|_v == 3} -> {Int|_v == 3 * len xs})
sum = \xs . 
  match xs with
    Nil -> zero
    Cons x3 x4 -> plus x3 (sum x4)

(Goals: 2)
(Measures: 1)
(Spec size: 12)
(Solution size: 22)

laurent-BCD: timeout
---------------------------------------------------------------
List-toFalse:
---------------------------------------------------------------
guarded powerset:
listToFalse :: (zs:{List Int|len _v == 0} -> {Bool|_v == False}) ^ (zs:{List Int|len _v > 0} -> {Bool|_v == False})
listToFalse = \zs . 
  match zs with
    Nil -> False
    Cons y ys -> listToFalse ys

(Goals: 2)
(Measures: 1)
(Spec size: 17)
(Solution size: 18)

either/or:
listToFalse :: (zs:{List Int|len _v == 0} -> {Bool|_v == False}) ^ (zs:{List Int|len _v > 0} -> {Bool|_v == False})
List-toFalse.sq:17: Error:
  Cannot find sufficiently strong refinements
  when checking
  ys :: {List Int|len _v > 0 && (len _v >= 0 && len _v < len zs)}
  in
  \zs . 
    match zs with
      Cons y ys -> listToFalse ys


laurent-BCD: timeout
---------------------------------------------------------------
TakeWhile:
---------------------------------------------------------------
guarded powerset:
takeWhile :: <p :: a -> Bool> . (pred:(x:a -> {Bool|_v == p x}) -> xs:List a -> List {a|p _v}) ^ (pred:(x:a -> {Bool|_v == p x}) -> xs:List {a|p _v} -> {List a|_v == xs})
takeWhile = \pred . \xs . 
    match xs with
      Nil -> Nil
      Cons y ys -> 
        if pred y
          then Cons y (takeWhile pred ys)
          else Nil

(Goals: 2)
(Measures: 1)
(Spec size: 18)
(Solution size: 30)

either/or:
takeWhile :: <p :: a -> Bool> . (pred:(x:a -> {Bool|_v == p x}) -> xs:List a -> List {a|p _v}) ^ (pred:(x:a -> {Bool|_v == p x}) -> xs:List {a|p _v} -> {List a|_v == xs})
takeWhile = \pred . \xs . 
    match xs with
      Nil -> Nil
      Cons y ys -> 
        if pred y
          then Cons y (takeWhile pred ys)
          else Nil

(Goals: 2)
(Measures: 1)
(Spec size: 18)
(Solution size: 30)

laurent-BCD: timeout
