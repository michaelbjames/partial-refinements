---------------------------------------------------------------
All-Neg:
---------------------------------------------------------------
guarded powerset:
allNeg :: (xs:{List {Int|_v < 0}|len _v >= 0} -> {Bool|_v == True}) ^ ((xs:{List {Int|_v < 0}|len _v > 0} -> {Bool|_v == True}) ^ (xs:{List Nat|len _v > 0} -> {Bool|_v == False}))
allNeg = \xs . 
  match xs with
    Nil -> True
    Cons y ys -> 
      if y >= 0
        then False
        else allNeg ys

(Goals: 2)
(Measures: 1)
(Spec size: 30)
(Solution size: 25)

either/or:
allNeg :: (xs:{List {Int|_v < 0}|len _v >= 0} -> {Bool|_v == True}) ^ ((xs:{List {Int|_v < 0}|len _v > 0} -> {Bool|_v == True}) ^ (xs:{List Nat|len _v > 0} -> {Bool|_v == False}))
allNeg = \xs . 
  match xs with
    Nil -> True
    Cons y ys -> 
      if y >= 0
        then False
        else allNeg ys

(Goals: 2)
(Measures: 1)
(Spec size: 30)
(Solution size: 25)

laurent-BCD:
allNeg :: (xs:{List {Int|_v < 0}|len _v >= 0} -> {Bool|_v == True}) ^ ((xs:{List {Int|_v < 0}|len _v > 0} -> {Bool|_v == True}) ^ (xs:{List Nat|len _v > 0} -> {Bool|_v == False}))
allNeg = \xs . 
  match xs with
    Nil -> True
    Cons y ys -> 
      if y >= 0
        then False
        else allNeg ys

(Goals: 2)
(Measures: 1)
(Spec size: 30)
(Solution size: 25)
---------------------------------------------------------------
List-Dict-Contains:
---------------------------------------------------------------
guarded powerset:
contains :: (x:Int -> arg0:List Pair Int b -> Bool) ^ (x:a -> arg0:{List Pair a b|len _v == 0} -> {Bool|_v == False})
List-Dict-Contains.sq:42: Error:
  Cannot find sufficiently strong refinements
  when checking
  contains :: x6:_ -> x5:_ -> Bool
  in
  \needle . \haystack . 
      match haystack with
        Cons x xs -> 
          match x with
            Pair xa xb -> 
              if xa == needle
                then True
                else contains (?? :: [_])
                       (?? :: [_])


either/or:
contains :: (x:Int -> arg0:List Pair Int b -> Bool) ^ (x:a -> arg0:{List Pair a b|len _v == 0} -> {Bool|_v == False})
List-Dict-Contains.sq:42: Error:
  Cannot match shape, unresolvable subtype:
  'a' : {a|_v == needle} </: 'Int' : {Int|U17} from label 'checkE-subtype'
  when checking needle :: Int in
  \needle . \haystack . 
      match haystack with
        Cons x xs -> 
          match x with
            Pair xa xb -> 
              if xa == needle
                then True
                else contains needle (?? :: [_])


laurent-BCD: timeout
---------------------------------------------------------------
List-Dict-Find:
---------------------------------------------------------------
guarded powerset:
find :: (arg2:List Pair Int b -> arg1:Int -> arg0:b -> b) ^ (arg2:{List Pair Int Int|len _v == 0} -> arg1:Int -> default:Int -> {Int|_v == default})
find = \haystack . \needle .
    \def . 
      match haystack with
        Nil -> def
        Cons x xs -> 
          match x with
            Pair xa xb -> 
              if xa == needle
                then xb
                else find xs needle def

(Goals: 5)
(Measures: 4)
(Spec size: 10)
(Solution size: 59)

either/or:
find :: (arg2:List Pair Int b -> arg1:Int -> arg0:b -> b) ^ (arg2:{List Pair Int Int|len _v == 0} -> arg1:Int -> default:Int -> {Int|_v == default})
List-Dict-Find.sq:33: Error:
  Cannot match shape, unresolvable subtype:
  'Int' : {Int|_v == x5} </: 'b' : b from label 'checkE-subtype'
  when checking
  find :: x7:_ -> x6:_ -> x5:_ -> b
  in
  \haystack . \needle . \def . 
        match haystack with
          Cons x xs -> 
            match x with
              Pair xa xb -> 
                if xa == needle
                  then xb
                  else find (?? :: [_])
                         (?? :: [_]) (?? :: [_])


laurent-BCD:
find :: (arg2:List Pair Int b -> arg1:Int -> arg0:b -> b) ^ (arg2:{List Pair Int Int|len _v == 0} -> arg1:Int -> default:Int -> {Int|_v == default})
find = \haystack . \needle .
    \def . 
      match haystack with
        Nil -> def
        Cons x xs -> 
          match x with
            Pair xa xb -> 
              if xa == needle
                then xb
                else find xs needle def

(Goals: 5)
(Measures: 4)
(Spec size: 10)
(Solution size: 59)
---------------------------------------------------------------
List-Even-Parity:
---------------------------------------------------------------
guarded powerset:
list_even_parity :: (xs:List Bool -> Bool) ^ ((xs:{List {Bool|_v == True}|len _v == 2 || len _v == 0} -> {Bool|_v == True}) ^ (xs:{List {Bool|_v == True}|len _v == 3 || len _v == 1} -> {Bool|_v == False}))
list_even_parity = \xs . 
  match xs with
    Nil -> True
    Cons y ys -> 
      if y
        then not (list_even_parity ys)
        else list_even_parity ys

(Goals: 2)
(Measures: 1)
(Spec size: 33)
(Solution size: 25)

either/or:
list_even_parity :: (xs:List Bool -> Bool) ^ ((xs:{List {Bool|_v == True}|len _v == 2 || len _v == 0} -> {Bool|_v == True}) ^ (xs:{List {Bool|_v == True}|len _v == 3 || len _v == 1} -> {Bool|_v == False}))
list_even_parity = \xs . 
  match xs with
    Nil -> True
    Cons y ys -> 
      if y
        then not (list_even_parity ys)
        else list_even_parity ys

(Goals: 2)
(Measures: 1)
(Spec size: 33)
(Solution size: 25)

laurent-BCD: timeout
---------------------------------------------------------------
List-Fold:
---------------------------------------------------------------
guarded powerset:
foldl :: (xs:List a -> f:(acc:b -> x:a -> b) -> seed:b -> b) ^ ((xs:List a -> f:(acc:Int -> arg0:a -> {Int|_v == acc + 1}) -> seed:Int -> {Int|_v == len xs + seed}) ^ (xs:List Int -> f:(acc:Int -> x:Int -> {Int|_v == acc + 1}) -> seed:Int -> {Int|_v == len xs + seed}))
foldl = \xs . \f . \seed . 
      match xs with
        Nil -> seed
        Cons y ys -> foldl ys f (f seed
                                   y)

(Goals: 2)
(Measures: 1)
(Spec size: 25)
(Solution size: 28)

either/or:
foldl :: (xs:List a -> f:(acc:b -> x:a -> b) -> seed:b -> b) ^ ((xs:List a -> f:(acc:Int -> arg0:a -> {Int|_v == acc + 1}) -> seed:Int -> {Int|_v == len xs + seed}) ^ (xs:List Int -> f:(acc:Int -> x:Int -> {Int|_v == acc + 1}) -> seed:Int -> {Int|_v == len xs + seed}))
List-Fold.sq:16: Error:
  Cannot match shape, unresolvable subtype:
  'Int' : {Int|_v == len x6 + x4} </: 'b' : b from label 'checkE-subtype'
  when checking
  foldl :: x6:_ -> x5:_ -> x4:_ -> b
  in
  \xs . \f . \seed . 
        match xs with
          Cons y ys -> foldl (?? :: [_])
                         (?? :: [_]) (?? :: [_])


laurent-BCD: timeout
---------------------------------------------------------------
List-Inc:
---------------------------------------------------------------
guarded powerset:
map :: f:(arg0:a -> b) -> xs:List a -> {List b|len _v == len xs}
map = \f . \xs . 
    match xs with
      Nil -> Nil
      Cons x3 x4 -> 
        let f0 = f in
        Cons (f x3) (map f0 x4)

list_inc_intersect :: (xs:List Int -> List Int) ^ ((xs:List {Int|_v == 1} -> List {Int|_v == 2}) ^ (xs:{List Int|len _v == 1} -> {List Int|len _v == 1}))
list_inc_intersect = \x . 
  let f = inc in
  map f x

(Goals: 4)
(Measures: 2)
(Spec size: 25)
(Solution size: 48)

either/or:
map :: f:(arg0:a -> b) -> xs:List a -> {List b|len _v == len xs}
map = \f . \xs . 
    match xs with
      Nil -> Nil
      Cons x3 x4 -> 
        let f0 = f in
        Cons (f x3) (map f0 x4)

list_inc_intersect :: (xs:List Int -> List Int) ^ ((xs:List {Int|_v == 1} -> List {Int|_v == 2}) ^ (xs:{List Int|len _v == 1} -> {List Int|len _v == 1}))
list_inc_intersect = \x . 
  let f = inc in
  map f x

(Goals: 4)
(Measures: 2)
(Spec size: 25)
(Solution size: 48)

laurent-BCD:
map :: f:(arg0:a -> b) -> xs:List a -> {List b|len _v == len xs}
map = \f . \xs . 
    match xs with
      Nil -> Nil
      Cons x3 x4 -> 
        let f0 = f in
        Cons (f x3) (map f0 x4)

list_inc_intersect :: (xs:List Int -> List Int) ^ ((xs:List {Int|_v == 1} -> List {Int|_v == 2}) ^ (xs:{List Int|len _v == 1} -> {List Int|len _v == 1}))
list_inc_intersect = \x . 
  let f = inc in
  map f x

(Goals: 4)
(Measures: 2)
(Spec size: 25)
(Solution size: 48)
---------------------------------------------------------------
List-Last:
---------------------------------------------------------------
guarded powerset:
list_last :: (xs:List Int -> Maybe Int) ^ ((xs:{List Int|len _v == 0} -> {Maybe Int|isNothing _v}) ^ (xs:{List Int|len _v > 0} -> {Maybe Int|!isNothing _v}))
list_last = \xs . 
  match xs with
    Nil -> Nothing
    Cons x rest -> 
      match rest with
        Nil -> Just x
        Cons y ys -> list_last rest

(Goals: 4)
(Measures: 3)
(Spec size: 19)
(Solution size: 39)

either/or:
list_last :: (xs:List Int -> Maybe Int) ^ ((xs:{List Int|len _v == 0} -> {Maybe Int|isNothing _v}) ^ (xs:{List Int|len _v > 0} -> {Maybe Int|!isNothing _v}))
list_last = \xs . 
  match xs with
    Nil -> Nothing
    Cons x rest -> 
      match rest with
        Nil -> Just x
        Cons y ys -> list_last rest

(Goals: 4)
(Measures: 3)
(Spec size: 19)
(Solution size: 39)

laurent-BCD: timeout
---------------------------------------------------------------
List-Length:
---------------------------------------------------------------
guarded powerset:
length :: (zs:{List Int|len _v == 0} -> {Int|_v == 0}) ^ (zs:{List Int|len _v > 0} -> {Int|_v == len zs})
length = \zs . 
  match zs with
    Nil -> 0
    Cons y ys -> 1 + (length ys)

(Goals: 2)
(Measures: 1)
(Spec size: 18)
(Solution size: 22)

either/or:
length :: (zs:{List Int|len _v == 0} -> {Int|_v == 0}) ^ (zs:{List Int|len _v > 0} -> {Int|_v == len zs})
List-Length.sq:17: Error:
  Cannot find sufficiently strong refinements
  when checking
  ys :: {List Int|len _v > 0 && (len _v >= 0 && len _v < len zs)}
  in
  \zs . 
    match zs with
      Cons y ys -> 1 + (length ys)


laurent-BCD: timeout
---------------------------------------------------------------
List-Snoc:
---------------------------------------------------------------
guarded powerset:
snoc :: (xs:List a -> x:a -> {List a|len _v == len xs + 1}) ^ ((xs:{List Int|_v == (Nil)} -> x:{Int|_v == 1} -> {List Int|_v == (Cons 1 (Nil))}) ^ (xs:{List Int|_v == (Cons 2 (Nil))} -> x:{Int|_v == 1} -> {List Int|_v == (Cons 2 ((Cons 1 (Nil))))}))
snoc = \xs . \x . 
    match xs with
      Nil -> Cons x Nil
      Cons y ys -> Cons y (snoc ys x)

(Goals: 2)
(Measures: 1)
(Spec size: 36)
(Solution size: 29)

either/or:
snoc :: (xs:List a -> x:a -> {List a|len _v == len xs + 1}) ^ ((xs:{List Int|_v == (Nil)} -> x:{Int|_v == 1} -> {List Int|_v == (Cons 1 (Nil))}) ^ (xs:{List Int|_v == (Cons 2 (Nil))} -> x:{Int|_v == 1} -> {List Int|_v == (Cons 2 ((Cons 1 (Nil))))}))
List-Snoc.sq:25: Error:
  Cannot match shape, unresolvable subtype:
  'Int' : Int </: 'a' : {a|U10} from label 'checkE-subtype'
  when checking
  snoc :: x9:_ -> x8:_ -> List a
  in
  \xs . \x . 
      match xs with
        Cons y ys -> Cons y (snoc
                               (?? :: [_]) (?? :: [_]))


laurent-BCD: timeout
---------------------------------------------------------------
List-Sum:
---------------------------------------------------------------
guarded powerset:
sum :: (xs:List Int -> Int) ^ (xs:List {Int|_v == 3} -> {Int|_v == 3 * len xs})
sum = \xs . 
  match xs with
    Nil -> 0
    Cons y ys -> plus y (sum ys)

(Goals: 2)
(Measures: 1)
(Spec size: 12)
(Solution size: 22)

either/or:
sum :: (xs:List Int -> Int) ^ (xs:List {Int|_v == 3} -> {Int|_v == 3 * len xs})
sum = \xs . 
  match xs with
    Nil -> 0
    Cons y ys -> plus y (sum ys)

(Goals: 2)
(Measures: 1)
(Spec size: 12)
(Solution size: 22)

laurent-BCD: timeout
---------------------------------------------------------------
List-toFalse:
---------------------------------------------------------------
guarded powerset:
listToFalse :: (zs:{List Int|len _v == 0} -> {Bool|_v == False}) ^ (zs:{List Int|len _v > 0} -> {Bool|_v == False})
listToFalse = \zs . 
  match zs with
    Nil -> False
    Cons y ys -> listToFalse ys

(Goals: 2)
(Measures: 1)
(Spec size: 17)
(Solution size: 18)

either/or:
listToFalse :: (zs:{List Int|len _v == 0} -> {Bool|_v == False}) ^ (zs:{List Int|len _v > 0} -> {Bool|_v == False})
List-toFalse.sq:17: Error:
  Cannot find sufficiently strong refinements
  when checking
  ys :: {List Int|len _v > 0 && (len _v >= 0 && len _v < len zs)}
  in
  \zs . 
    match zs with
      Cons y ys -> listToFalse ys


laurent-BCD: timeout
---------------------------------------------------------------
TakeWhile:
---------------------------------------------------------------
guarded powerset:
takeWhile :: <p :: a -> Bool> . (pred:(x:a -> {Bool|_v == p x}) -> xs:List a -> List {a|p _v}) ^ (pred:(x:a -> {Bool|_v == p x}) -> xs:List {a|p _v} -> {List a|_v == xs})
takeWhile = \pred . \xs . 
    match xs with
      Nil -> Nil
      Cons y ys -> 
        if pred y
          then Cons y (takeWhile pred ys)
          else Nil

(Goals: 2)
(Measures: 1)
(Spec size: 18)
(Solution size: 30)

either/or:
takeWhile :: <p :: a -> Bool> . (pred:(x:a -> {Bool|_v == p x}) -> xs:List a -> List {a|p _v}) ^ (pred:(x:a -> {Bool|_v == p x}) -> xs:List {a|p _v} -> {List a|_v == xs})
takeWhile = \pred . \xs . 
    match xs with
      Nil -> Nil
      Cons y ys -> 
        if pred y
          then Cons y (takeWhile pred ys)
          else Nil

(Goals: 2)
(Measures: 1)
(Spec size: 18)
(Solution size: 30)

laurent-BCD: timeout
