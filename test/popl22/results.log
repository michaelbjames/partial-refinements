---------------------------------------------------------------
All-Neg:
---------------------------------------------------------------
guarded powerset:
allNeg :: (xs:{List {Int|_v < 0}|len _v >= 0} -> {Bool|_v == True}) ^ (xs:List Int -> {Bool|xs == (Cons (-1) ((Cons 1 (Nil)))) || xs == (Cons 1 (Nil)) ==> _v == False})
allNeg = \xs . 
  match xs with
    Nil -> true
    Cons x3 x4 -> 
      if x3 >= 0
        then false
        else allNeg x4

(Goals: 2)
(Measures: 1)
(Spec size: 31)
(Solution size: 25)

either/or:
allNeg :: (xs:{List {Int|_v < 0}|len _v >= 0} -> {Bool|_v == True}) ^ (xs:List Int -> {Bool|xs == (Cons (-1) ((Cons 1 (Nil)))) || xs == (Cons 1 (Nil)) ==> _v == False})
allNeg = \xs . 
  match xs with
    Nil -> true
    Cons x3 x4 -> 
      if x3 >= 0
        then false
        else allNeg x4

(Goals: 2)
(Measures: 1)
(Spec size: 31)
(Solution size: 25)

laurent-BCD: timeout
---------------------------------------------------------------
List-Dict-Contains:
---------------------------------------------------------------
guarded powerset:
synquid: Z3 error: Sort mismatch between first argument and argument 2

either/or:
contains :: (needle:a -> haystack:{List Pair {a|_v != needle} a|len _v > 0} -> {Bool|_v == False}) ^ ((needle:a -> haystack:{List Pair {a|_v == needle} a|len _v > 0} -> {Bool|_v == True}) ^ (needle:a -> haystack:{List Pair a a|len _v == 0} -> {Bool|_v == False}))
contains = \needle . \haystack .
    
    match haystack with
      Nil -> false
      Cons x4 x5 -> 
        match x4 with
          Pair x6 x7 -> 
            if needle == x6
              then true
              else false

(Goals: 4)
(Measures: 3)
(Spec size: 30)
(Solution size: 34)

laurent-BCD:
---------------------------------------------------------------
List-Dict-Find:
---------------------------------------------------------------
guarded powerset:
find :: (d:List Pair Int b -> k:Int -> default:b -> b) ^ (d:{List Pair Int Int|len _v == 0} -> k:Int -> default:Int -> {Int|_v == default})
find = \d . \k . \default .
      default

(Goals: 6)
(Measures: 5)
(Spec size: 10)
(Solution size: 54)

either/or:
find :: (d:List Pair Int b -> k:Int -> default:b -> b) ^ (d:{List Pair Int Int|len _v == 0} -> k:Int -> default:Int -> {Int|_v == default})
find = \d . \k . \default .
      default

(Goals: 6)
(Measures: 5)
(Spec size: 10)
(Solution size: 54)

laurent-BCD:
find :: (d:List Pair Int b -> k:Int -> default:b -> b) ^ (d:{List Pair Int Int|len _v == 0} -> k:Int -> default:Int -> {Int|_v == default})
find = \d . \k . \default .
      default

(Goals: 6)
(Measures: 5)
(Spec size: 10)
(Solution size: 54)
---------------------------------------------------------------
List-Even-Parity:
---------------------------------------------------------------
guarded powerset:
list_even_parity :: xs:List Bool -> {Bool|(((((xs == (Cons True (Nil)) ==> _v == False) && (xs == (Cons False (Nil)) ==> _v == True)) && (xs == (Cons True ((Cons False (Nil)))) ==> _v == False)) && (xs == (Cons False ((Cons True (Nil)))) ==> _v == False)) && (xs == (Cons False ((Cons False (Nil)))) ==> _v == True)) && True}
list_even_parity = \xs . 
  match xs with
    Nil -> true
    Cons x2 x3 -> 
      if x2
        then not x2
        else 
          match x3 with
            Nil -> true
            Cons x5 x6 -> 
              if x5
                then x2
                else true

(Goals: 2)
(Measures: 1)
(Spec size: 60)
(Solution size: 27)

either/or:
list_even_parity :: xs:List Bool -> {Bool|(((((xs == (Cons True (Nil)) ==> _v == False) && (xs == (Cons False (Nil)) ==> _v == True)) && (xs == (Cons True ((Cons False (Nil)))) ==> _v == False)) && (xs == (Cons False ((Cons True (Nil)))) ==> _v == False)) && (xs == (Cons False ((Cons False (Nil)))) ==> _v == True)) && True}
list_even_parity = \xs . 
  match xs with
    Nil -> true
    Cons x2 x3 -> 
      if x2
        then not x2
        else 
          match x3 with
            Nil -> true
            Cons x5 x6 -> 
              if x5
                then x2
                else true

(Goals: 2)
(Measures: 1)
(Spec size: 60)
(Solution size: 27)

laurent-BCD:
list_even_parity :: xs:List Bool -> {Bool|(((((xs == (Cons True (Nil)) ==> _v == False) && (xs == (Cons False (Nil)) ==> _v == True)) && (xs == (Cons True ((Cons False (Nil)))) ==> _v == False)) && (xs == (Cons False ((Cons True (Nil)))) ==> _v == False)) && (xs == (Cons False ((Cons False (Nil)))) ==> _v == True)) && True}
list_even_parity = \xs . 
  match xs with
    Nil -> true
    Cons x2 x3 -> 
      if x2
        then not x2
        else 
          match x3 with
            Nil -> true
            Cons x5 x6 -> 
              if x5
                then x2
                else true

(Goals: 2)
(Measures: 1)
(Spec size: 60)
(Solution size: 27)
---------------------------------------------------------------
List-Fold:
---------------------------------------------------------------
guarded powerset: timeout

either/or:

laurent-BCD:
---------------------------------------------------------------
List-Inc:
---------------------------------------------------------------
guarded powerset:
map :: f:(arg0:a -> b) -> xs:List a -> {List b|len _v == len xs}
map = \f . \xs . 
    match xs with
      Nil -> Nil
      Cons x3 x4 -> 
        let f0 = f in
        Cons (f x3) (map f0 x4)

list_inc_intersect :: (xs:List Int -> List Int) ^ ((xs:List {Int|_v == 1} -> List {Int|_v == 2}) ^ (xs:{List Int|len _v == 1} -> {List Int|len _v == 1}))
list_inc_intersect = \xs . map
                             inc xs

(Goals: 4)
(Measures: 2)
(Spec size: 25)
(Solution size: 46)

either/or:
map :: f:(arg0:a -> b) -> xs:List a -> {List b|len _v == len xs}
map = \f . \xs . 
    match xs with
      Nil -> Nil
      Cons x3 x4 -> 
        let f0 = f in
        Cons (f x3) (map f0 x4)

list_inc_intersect :: (xs:List Int -> List Int) ^ ((xs:List {Int|_v == 1} -> List {Int|_v == 2}) ^ (xs:{List Int|len _v == 1} -> {List Int|len _v == 1}))
list_inc_intersect = \xs . map
                             inc xs

(Goals: 4)
(Measures: 2)
(Spec size: 25)
(Solution size: 46)

laurent-BCD: timeout
---------------------------------------------------------------
List-Last:
---------------------------------------------------------------
guarded powerset:
list_last :: (xs:List Int -> {Maybe Int|(xs == (Cons 2 (Nil)) || xs == (Cons 1 ((Cons 2 (Nil))))) || xs == (Cons 0 ((Cons 1 ((Cons 2 (Nil)))))) ==> _v == (Just 2)}) ^ (xs:List a -> Maybe a)
list_last = \xs . 
  match xs with
    Nil -> Nothing
    Cons x3 x4 -> 
      match x4 with
        Nil -> Just x3
        Cons x6 x7 -> list_last x4

(Goals: 4)
(Measures: 3)
(Spec size: 34)
(Solution size: 39)

either/or:
list_last :: (xs:List Int -> {Maybe Int|(xs == (Cons 2 (Nil)) || xs == (Cons 1 ((Cons 2 (Nil))))) || xs == (Cons 0 ((Cons 1 ((Cons 2 (Nil)))))) ==> _v == (Just 2)}) ^ (xs:List a -> Maybe a)
List-Last.sq:35: Error:
  no more programs.


laurent-BCD: timeout
---------------------------------------------------------------
List-Length:
---------------------------------------------------------------
guarded powerset:
length :: (zs:{List Int|len _v == 0} -> {Int|_v == 0}) ^ (zs:{List Int|len _v > 0} -> {Int|_v == len zs})
length = \zs . 
  match zs with
    Nil -> zero
    Cons x3 x4 -> inc (length x4)

(Goals: 2)
(Measures: 1)
(Spec size: 18)
(Solution size: 20)

either/or:
length :: (zs:{List Int|len _v == 0} -> {Int|_v == 0}) ^ (zs:{List Int|len _v > 0} -> {Int|_v == len zs})
length = \zs . 
  match zs with
    Nil -> zero
    Cons x3 x4 -> 
      match x4 with
        Nil -> inc zero
        Cons x6 x7 -> inc (length x4)

(Goals: 2)
(Measures: 1)
(Spec size: 18)
(Solution size: 25)

laurent-BCD: timeout
---------------------------------------------------------------
List-Snoc:
---------------------------------------------------------------
guarded powerset:
snoc :: (xs:List a -> x:a -> {List a|len _v == len xs + 1}) ^ ((xs:{List Int|_v == (Nil)} -> x:{Int|_v == 1} -> {List Int|_v == (Cons 1 (Nil))}) ^ (xs:{List Int|_v == (Cons 2 (Nil))} -> x:{Int|_v == 1} -> {List Int|_v == (Cons 2 ((Cons 1 (Nil))))}))
snoc = \xs . \x . 
    match xs with
      Nil -> Cons x xs
      Cons x6 x7 -> Cons x6 (Cons x
                               x7)

(Goals: 2)
(Measures: 1)
(Spec size: 36)
(Solution size: 29)

either/or:
snoc :: (xs:List a -> x:a -> {List a|len _v == len xs + 1}) ^ ((xs:{List Int|_v == (Nil)} -> x:{Int|_v == 1} -> {List Int|_v == (Cons 1 (Nil))}) ^ (xs:{List Int|_v == (Cons 2 (Nil))} -> x:{Int|_v == 1} -> {List Int|_v == (Cons 2 ((Cons 1 (Nil))))}))
snoc = \xs . \x . 
    match xs with
      Nil -> Cons x xs
      Cons x6 x7 -> Cons x6 (Cons x
                               x7)

(Goals: 2)
(Measures: 1)
(Spec size: 36)
(Solution size: 29)

laurent-BCD: timeout
---------------------------------------------------------------
List-Sum:
---------------------------------------------------------------
guarded powerset:
sum :: (xs:List Int -> Int) ^ (xs:List {Int|_v == 3} -> {Int|_v == 3 * len xs})
sum = \xs . 
  match xs with
    Nil -> zero
    Cons x3 x4 -> plus x3 (sum x4)

(Goals: 2)
(Measures: 1)
(Spec size: 12)
(Solution size: 22)

either/or:
sum :: (xs:List Int -> Int) ^ (xs:List {Int|_v == 3} -> {Int|_v == 3 * len xs})
sum = \xs . 
  match xs with
    Nil -> zero
    Cons x3 x4 -> plus x3 (sum x4)

(Goals: 2)
(Measures: 1)
(Spec size: 12)
(Solution size: 22)

laurent-BCD: timeout
---------------------------------------------------------------
Maybe-fmap:
---------------------------------------------------------------
guarded powerset:

either/or:

laurent-BCD:
---------------------------------------------------------------
TakeWhile:
---------------------------------------------------------------
guarded powerset:

either/or:

laurent-BCD:
