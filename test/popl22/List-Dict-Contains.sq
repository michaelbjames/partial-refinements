data Pair a b where
	Pair :: x: a -> y: b -> Pair a b

measure fst :: Pair a b -> a where
  Pair x y -> x

measure snd :: Pair a b -> b where
  Pair x y -> y


data List a where
	Nil :: List a
	Cons :: x: a -> xs: List a -> List a

termination measure len :: List a -> {Int | _v >= 0} where
  Nil -> 0
  Cons x xs -> 1 + len xs

qualifier { len _v < len x, len _v >= 0, x == y }

false :: {Bool | _v == False}
true :: {Bool | _v == True}

{-
Intersection: Not strong enough. I'm not sure why.
We can use an abstract `a`, but need a concrete value in the Pair so we can give
an example.
Note: use -f allarguments or -f nonterminating; since the List must come second
but it's decreasing.
-}
contains :: (xs:List (Pair Int b) -> x:Int -> Bool) ^
            -- Empty list trivially doesn't contain anything
            (xs:{List (Pair a b) | len _v == 0} -> x:a -> {Bool | _v == False}) ^
            -- The list where x is in every element definitely contains x
            -- (xs:{List (Pair {Int | _v == 1} b) | len _v > 0} -> x: {Int| _v == 1} -> {Bool | _v == True}) ^
            -- (xs:{List (Pair a b) | len _v > 0} -> x: a -> {Bool | (fst (head xs) == x) ==> (_v == True)}) ^
            -- The list where x is in no element definitely does not contains x
            -- (List (Pair {Int | _v != x} b) -> x: Int -> {Bool | _v == False})
            -- Lastly we need an example to force a recursive call
            (xs:List (Pair Int Int) -> x:{Int|_v == 1} -> {Bool |
              (xs == (Nil) ==> (_v == False)) &&
              (xs == (Cons (Pair 1 0) Nil) ==> (_v == True)) &&
              (xs == (Cons (Pair 2 0) Nil) ==> (_v == False)) &&
              (xs == (Cons (Pair 2 0) (Cons (Pair 1 0) Nil)) ==> (_v == True)) &&
              (xs == (Cons (Pair 2 0) (Cons (Pair 2 0) Nil)) ==> (_v == False)) })
contains = ??
