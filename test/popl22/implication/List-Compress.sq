-- Remove adjacent duplicates

eq :: x: a -> y: a -> {Bool | _v == (x == y)}
neq :: x: a -> y: a -> {Bool | _v == (x != y)}

data PList a <p :: a -> PList a -> Bool> where
	Nil :: PList a <p>
	Cons :: x: a -> xs: {PList a <p> | p x _v} -> PList a <p>

termination measure len :: PList a -> {Int | _v >= 0} where
  Nil -> 0
  Cons x xs -> 1 + len xs

measure elems :: PList a -> Set a where
  Nil -> []
  Cons x xs -> [x] + elems xs

measure heads :: PList a -> Set a where
  Nil -> []
  Cons x xs -> [x]

type List a = PList a <{True}>
type CList a = PList a <{!(_0 in heads _1)}>


compress_int :: xs: List Int -> {List Int |
    (xs == Nil ==> (_v == Nil)) &&
    (xs == (Cons 1 Nil) ==> (_v == (Cons 1 Nil))) &&
    (xs == (Cons 1 (Cons 1 Nil)) ==> (_v == (Cons 1 Nil))) &&
    (xs == (Cons 2 (Cons 1 (Cons 1 Nil))) ==> (_v == (Cons 2 (Cons 1 Nil)))) &&
    (xs == (Cons 2 (Cons 2 (Cons 1 (Cons 1 Nil)))) ==> (_v == (Cons 2 (Cons 1 Nil)))) &&

    (xs == (Cons 1 (Cons 1 (Cons 1 Nil))) ==> (_v == (Cons 1 Nil))) &&

    (xs == (Cons 2 (Cons 1 Nil)) ==> (_v == (Cons 2 (Cons 1 Nil)))) &&
    (xs == (Cons 3 (Cons 2 (Cons 1 Nil))) ==> (_v == (Cons 3 (Cons 2 (Cons 1 Nil))))) &&

    True
    }
compress_int = ??
-- compress_int = \xs .
  -- match xs with
  --   Nil -> xs
  --   Cons x2 x3 ->
  --     match x3 with
  --       Nil -> xs
  --       Cons x4 x5 ->
  --         if x2 == x4
  --           then compress_int x3
  --           else Cons x2 (compress_int x3)